# pragma pylint: disable=missing-docstring, invalid-name, pointless-string-statement
# flake8: noqa: F401
# isort: skip_file
# AUTO-GENERATED STRATEGY - DO NOT EDIT MANUALLY
# Generated: 2026-02-12T22:32:18.197953
# Generation: 1
# Strategy ID: Gen001_Strat_004

import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
from pandas import DataFrame
from typing import Dict, Optional, Union, Tuple
from functools import reduce

from freqtrade.strategy import (
    IStrategy,
    Trade,
    Order,
    PairLocks,
    informative,
    BooleanParameter,
    CategoricalParameter,
    DecimalParameter,
    IntParameter,
    RealParameter,
    timeframe_to_minutes,
    timeframe_to_next_date,
    timeframe_to_prev_date,
    merge_informative_pair,
    stoploss_from_absolute,
    stoploss_from_open,
    AnnotationType,
)

import talib.abstract as ta
from technical import qtpylib


class Strategy_Gen001_Strat_004(IStrategy):
    """
    Auto-generated strategy using 5 indicators
    
    AUTO-GENERATED by GAFreqTrade
    Generation: 1
    Parent Strategies: None (Random)
    """
    
    INTERFACE_VERSION = 3
    
    # Basic Settings
    timeframe = "5m"
    can_short: bool = False
    
    # ROI table
    minimal_roi = {'4': 0.134, '21': 0.078, '43': 0.059, '75': 0.011}
    
    # Stoploss
    stoploss = -0.078
    
    # Trailing stoploss
    trailing_stop = True
    trailing_stop_positive = 0.015
    trailing_stop_positive_offset = 0.029
    trailing_only_offset_is_reached = True
    
    # Run "populate_indicators()" only for new candle
    process_only_new_candles = True
    
    # Exit signal
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    
    # Number of candles the strategy requires before producing valid signals
    startup_candle_count: int = 32
    
    # Strategy parameters
    mfi_sell_threshold = IntParameter(51, 91, default=71, space='buy')
    
    # Order types
    order_types = {
        "entry": "limit",
        "exit": "limit",
        "stoploss": "market",
        "stoploss_on_exchange": False
    }
    
    order_time_in_force = {
        "entry": "GTC",
        "exit": "GTC"
    }
    
    def informative_pairs(self):
        return []
    
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Adds TA indicators to the given DataFrame
        """
        # EMA
        dataframe["ema_32"] = ta.EMA(dataframe, timeperiod=32)

        # MACD
        macd = ta.MACD(dataframe, fastperiod=14, slowperiod=21, signalperiod=11)
        dataframe["macd"] = macd["macd"]
        dataframe["macdsignal"] = macd["macdsignal"]
        dataframe["macdhist"] = macd["macdhist"]

        # Stochastic
        stoch = ta.STOCH(dataframe, fastk_period=5, slowk_period=3, slowd_period=2)
        dataframe["slowk"] = stoch["slowk"]
        dataframe["slowd"] = stoch["slowd"]

        # MFI
        dataframe["mfi"] = ta.MFI(dataframe, timeperiod=12)

        # Bollinger Bands
        bollinger = qtpylib.bollinger_bands(qtpylib.typical_price(dataframe), window=18, stds=1.57)
        dataframe["bb_lowerband"] = bollinger["lower"]
        dataframe["bb_middleband"] = bollinger["mid"]
        dataframe["bb_upperband"] = bollinger["upper"]
        dataframe["bb_percent"] = (dataframe["close"] - dataframe["bb_lowerband"]) / (dataframe["bb_upperband"] - dataframe["bb_lowerband"])
        dataframe["bb_width"] = (dataframe["bb_upperband"] - dataframe["bb_lowerband"]) / dataframe["bb_middleband"]

        
        return dataframe
    
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the entry signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["close"] > dataframe["ema_32"])
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'enter_long'
            ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the exit signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["close"] < dataframe["ema_32"])
        conditions.append(dataframe["macdhist"] < 0)
        conditions.append(dataframe["mfi"] > self.mfi_sell_threshold.value)
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'exit_long'
            ] = 1
        
        return dataframe
