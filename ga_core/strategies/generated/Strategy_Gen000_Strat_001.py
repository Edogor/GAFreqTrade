# pragma pylint: disable=missing-docstring, invalid-name, pointless-string-statement
# flake8: noqa: F401
# isort: skip_file
# AUTO-GENERATED STRATEGY - DO NOT EDIT MANUALLY
# Generated: 2026-02-12T22:28:13.454433
# Generation: 0
# Strategy ID: Gen000_Strat_001

import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
from pandas import DataFrame
from typing import Dict, Optional, Union, Tuple
from functools import reduce

from freqtrade.strategy import (
    IStrategy,
    Trade,
    Order,
    PairLocks,
    informative,
    BooleanParameter,
    CategoricalParameter,
    DecimalParameter,
    IntParameter,
    RealParameter,
    timeframe_to_minutes,
    timeframe_to_next_date,
    timeframe_to_prev_date,
    merge_informative_pair,
    stoploss_from_absolute,
    stoploss_from_open,
    AnnotationType,
)

import talib.abstract as ta
from technical import qtpylib


class Strategy_Gen000_Strat_001(IStrategy):
    """
    Auto-generated strategy using 6 indicators
    
    AUTO-GENERATED by GAFreqTrade
    Generation: 0
    Parent Strategies: None (Random)
    """
    
    INTERFACE_VERSION = 3
    
    # Basic Settings
    timeframe = "1h"
    can_short: bool = False
    
    # ROI table
    minimal_roi = {'10': 0.136, '27': 0.092, '50': 0.037, '112': 0.02}
    
    # Stoploss
    stoploss = -0.098
    
    # Trailing stoploss
    trailing_stop = True
    trailing_stop_positive = 0.011
    trailing_stop_positive_offset = 0.012
    trailing_only_offset_is_reached = True
    
    # Run "populate_indicators()" only for new candle
    process_only_new_candles = True
    
    # Exit signal
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    
    # Number of candles the strategy requires before producing valid signals
    startup_candle_count: int = 38
    
    # Strategy parameters
    cci_buy_threshold = IntParameter(0, -65, default=-85, space='buy')
    mfi_sell_threshold = IntParameter(49, 89, default=69, space='buy')
    
    # Order types
    order_types = {
        "entry": "limit",
        "exit": "limit",
        "stoploss": "market",
        "stoploss_on_exchange": False
    }
    
    order_time_in_force = {
        "entry": "GTC",
        "exit": "GTC"
    }
    
    def informative_pairs(self):
        return []
    
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Adds TA indicators to the given DataFrame
        """
        # EMA
        dataframe["ema_38"] = ta.EMA(dataframe, timeperiod=38)

        # CCI
        dataframe["cci"] = ta.CCI(dataframe, timeperiod=11)

        # MFI
        dataframe["mfi"] = ta.MFI(dataframe, timeperiod=10)

        # Bollinger Bands
        bollinger = qtpylib.bollinger_bands(qtpylib.typical_price(dataframe), window=22, stds=2.23)
        dataframe["bb_lowerband"] = bollinger["lower"]
        dataframe["bb_middleband"] = bollinger["mid"]
        dataframe["bb_upperband"] = bollinger["upper"]
        dataframe["bb_percent"] = (dataframe["close"] - dataframe["bb_lowerband"]) / (dataframe["bb_upperband"] - dataframe["bb_lowerband"])
        dataframe["bb_width"] = (dataframe["bb_upperband"] - dataframe["bb_lowerband"]) / dataframe["bb_middleband"]

        # RSI
        dataframe["rsi"] = ta.RSI(dataframe, timeperiod=19)

        # ATR
        dataframe["atr"] = ta.ATR(dataframe, timeperiod=13)

        
        return dataframe
    
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the entry signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["close"] < dataframe["bb_lowerband"])
        conditions.append(dataframe["cci"] < self.cci_buy_threshold.value)
        conditions.append(dataframe["close"] > dataframe["ema_38"])
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'enter_long'
            ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the exit signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["mfi"] > self.mfi_sell_threshold.value)
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'exit_long'
            ] = 1
        
        return dataframe
