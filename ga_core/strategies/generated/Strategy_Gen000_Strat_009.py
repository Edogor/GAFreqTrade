# pragma pylint: disable=missing-docstring, invalid-name, pointless-string-statement
# flake8: noqa: F401
# isort: skip_file
# AUTO-GENERATED STRATEGY - DO NOT EDIT MANUALLY
# Generated: 2026-02-12T22:32:18.196801
# Generation: 0
# Strategy ID: Gen000_Strat_009

import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
from pandas import DataFrame
from typing import Dict, Optional, Union, Tuple
from functools import reduce

from freqtrade.strategy import (
    IStrategy,
    Trade,
    Order,
    PairLocks,
    informative,
    BooleanParameter,
    CategoricalParameter,
    DecimalParameter,
    IntParameter,
    RealParameter,
    timeframe_to_minutes,
    timeframe_to_next_date,
    timeframe_to_prev_date,
    merge_informative_pair,
    stoploss_from_absolute,
    stoploss_from_open,
    AnnotationType,
)

import talib.abstract as ta
from technical import qtpylib


class Strategy_Gen000_Strat_009(IStrategy):
    """
    Auto-generated strategy using 6 indicators
    
    AUTO-GENERATED by GAFreqTrade
    Generation: 0
    Parent Strategies: None (Random)
    """
    
    INTERFACE_VERSION = 3
    
    # Basic Settings
    timeframe = "1h"
    can_short: bool = False
    
    # ROI table
    minimal_roi = {'3': 0.179, '18': 0.093, '46': 0.05, '89': 0.016}
    
    # Stoploss
    stoploss = -0.114
    
    # Trailing stoploss
    trailing_stop = True
    trailing_stop_positive = 0.01
    trailing_stop_positive_offset = 0.025
    trailing_only_offset_is_reached = True
    
    # Run "populate_indicators()" only for new candle
    process_only_new_candles = True
    
    # Exit signal
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    
    # Number of candles the strategy requires before producing valid signals
    startup_candle_count: int = 71
    
    # Strategy parameters
    stoch_buy_threshold = IntParameter(0, 39, default=19, space='buy')
    
    # Order types
    order_types = {
        "entry": "limit",
        "exit": "limit",
        "stoploss": "market",
        "stoploss_on_exchange": False
    }
    
    order_time_in_force = {
        "entry": "GTC",
        "exit": "GTC"
    }
    
    def informative_pairs(self):
        return []
    
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Adds TA indicators to the given DataFrame
        """
        # ADX
        dataframe["adx"] = ta.ADX(dataframe, timeperiod=18)

        # MACD
        macd = ta.MACD(dataframe, fastperiod=9, slowperiod=28, signalperiod=7)
        dataframe["macd"] = macd["macd"]
        dataframe["macdsignal"] = macd["macdsignal"]
        dataframe["macdhist"] = macd["macdhist"]

        # Bollinger Bands
        bollinger = qtpylib.bollinger_bands(qtpylib.typical_price(dataframe), window=19, stds=2.08)
        dataframe["bb_lowerband"] = bollinger["lower"]
        dataframe["bb_middleband"] = bollinger["mid"]
        dataframe["bb_upperband"] = bollinger["upper"]
        dataframe["bb_percent"] = (dataframe["close"] - dataframe["bb_lowerband"]) / (dataframe["bb_upperband"] - dataframe["bb_lowerband"])
        dataframe["bb_width"] = (dataframe["bb_upperband"] - dataframe["bb_lowerband"]) / dataframe["bb_middleband"]

        # SMA
        dataframe["sma_71"] = ta.SMA(dataframe, timeperiod=71)

        # Stochastic
        stoch = ta.STOCH(dataframe, fastk_period=4, slowk_period=2, slowd_period=3)
        dataframe["slowk"] = stoch["slowk"]
        dataframe["slowd"] = stoch["slowd"]

        # ATR
        dataframe["atr"] = ta.ATR(dataframe, timeperiod=16)

        
        return dataframe
    
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the entry signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["slowk"] < self.stoch_buy_threshold.value)
        conditions.append(dataframe["close"] > dataframe["sma_71"])
        conditions.append((qtpylib.crossed_above(dataframe["close"], dataframe["sma_71"])))
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'enter_long'
            ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the exit signal for the given dataframe
        """
        conditions = []
        
        conditions.append((qtpylib.crossed_below(dataframe["macd"], dataframe["macdsignal"])))
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'exit_long'
            ] = 1
        
        return dataframe
