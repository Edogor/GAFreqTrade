# pragma pylint: disable=missing-docstring, invalid-name, pointless-string-statement
# flake8: noqa: F401
# isort: skip_file
# AUTO-GENERATED STRATEGY - DO NOT EDIT MANUALLY
# Generated: 2026-02-12T22:32:18.197795
# Generation: 1
# Strategy ID: Gen001_Strat_003

import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
from pandas import DataFrame
from typing import Dict, Optional, Union, Tuple
from functools import reduce

from freqtrade.strategy import (
    IStrategy,
    Trade,
    Order,
    PairLocks,
    informative,
    BooleanParameter,
    CategoricalParameter,
    DecimalParameter,
    IntParameter,
    RealParameter,
    timeframe_to_minutes,
    timeframe_to_next_date,
    timeframe_to_prev_date,
    merge_informative_pair,
    stoploss_from_absolute,
    stoploss_from_open,
    AnnotationType,
)

import talib.abstract as ta
from technical import qtpylib


class Strategy_Gen001_Strat_003(IStrategy):
    """
    Auto-generated strategy using 3 indicators
    
    AUTO-GENERATED by GAFreqTrade
    Generation: 1
    Parent Strategies: None (Random)
    """
    
    INTERFACE_VERSION = 3
    
    # Basic Settings
    timeframe = "1h"
    can_short: bool = False
    
    # ROI table
    minimal_roi = {'9': 0.15, '24': 0.08, '50': 0.048, '70': 0.011}
    
    # Stoploss
    stoploss = -0.109
    
    # Trailing stoploss
    trailing_stop = False
    trailing_stop_positive = 0.0
    trailing_stop_positive_offset = 0.0
    trailing_only_offset_is_reached = False
    
    # Run "populate_indicators()" only for new candle
    process_only_new_candles = True
    
    # Exit signal
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    
    # Number of candles the strategy requires before producing valid signals
    startup_candle_count: int = 30
    
    # Strategy parameters
    adx_threshold = IntParameter(1, 41, default=21, space='buy')
    mfi_sell_threshold = IntParameter(46, 86, default=66, space='buy')
    
    # Order types
    order_types = {
        "entry": "limit",
        "exit": "limit",
        "stoploss": "market",
        "stoploss_on_exchange": False
    }
    
    order_time_in_force = {
        "entry": "GTC",
        "exit": "GTC"
    }
    
    def informative_pairs(self):
        return []
    
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Adds TA indicators to the given DataFrame
        """
        # ATR
        dataframe["atr"] = ta.ATR(dataframe, timeperiod=12)

        # MFI
        dataframe["mfi"] = ta.MFI(dataframe, timeperiod=17)

        # ADX
        dataframe["adx"] = ta.ADX(dataframe, timeperiod=17)

        
        return dataframe
    
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the entry signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["adx"] > self.adx_threshold.value)
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'enter_long'
            ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the exit signal for the given dataframe
        """
        conditions = []
        
        conditions.append(dataframe["mfi"] > self.mfi_sell_threshold.value)
        
        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'exit_long'
            ] = 1
        
        return dataframe
